import { describe, it, expect } from 'vitest';
import { exportToKubernetes, type KubernetesExportOptions } from '@/lib/export/kubernetesExport';
import type { InfraSpec, InfraNodeSpec, ConnectionSpec } from '@/types';

describe('KubernetesExport', () => {
  // Helper to create a basic InfraSpec
  const createSpec = (
    nodes: InfraNodeSpec[],
    connections: ConnectionSpec[] = []
  ): InfraSpec => ({
    nodes,
    connections,
  });

  // Helper to create a node
  const createNode = (
    id: string,
    type: InfraNodeSpec['type'],
    label: string,
    zone?: string
  ): InfraNodeSpec => ({
    id,
    type,
    label,
    zone,
  });

  describe('exportToKubernetes', () => {
    describe('Basic Export', () => {
      it('should generate valid K8s YAML', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('apiVersion:');
        expect(result).toContain('kind:');
        expect(result).toContain('metadata:');
        expect(result).toContain('spec:');
      });

      it('should include header comment with namespace and timestamp', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, { namespace: 'production' });

        expect(result).toContain('# Kubernetes manifests generated by InfraFlow');
        expect(result).toContain('# Namespace: production');
        expect(result).toContain('# Generated:');
      });
    });

    describe('Metadata', () => {
      it('should include proper metadata in resources', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec, { namespace: 'app-ns' });

        expect(result).toContain('name:');
        expect(result).toContain('namespace: app-ns');
        expect(result).toContain('labels:');
        expect(result).toContain('managed-by: infraflow');
      });

      it('should include app label in metadata', () => {
        const spec = createSpec([createNode('my-app', 'app-server', 'My Application')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('app: my-app');
      });

      it('should include tier label for relevant resources', () => {
        const spec = createSpec([
          createNode('web-1', 'web-server', 'Web Server'),
          createNode('db-1', 'db-server', 'Database'),
        ]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('tier: web');
        expect(result).toContain('tier: database');
      });
    });

    describe('Namespace Handling', () => {
      it('should use default namespace when not specified', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('namespace: default');
      });

      it('should generate namespace resource when includeNamespace is true and namespace is not default', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, {
          namespace: 'production',
          includeNamespace: true,
        });

        expect(result).toContain('kind: Namespace');
        expect(result).toContain('name: production');
      });

      it('should not generate namespace resource for default namespace', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, {
          namespace: 'default',
          includeNamespace: true,
        });

        expect(result).not.toContain('kind: Namespace');
      });

      it('should not generate namespace resource when includeNamespace is false', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, {
          namespace: 'production',
          includeNamespace: false,
        });

        expect(result).not.toContain('kind: Namespace');
      });
    });

    describe('Compute Resources', () => {
      it('should generate Deployment for web-server', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: Deployment');
        expect(result).toContain('name: web-1');
        expect(result).toContain('tier: web');
        expect(result).toContain('readinessProbe:');
        expect(result).toContain('livenessProbe:');
      });

      it('should generate Deployment for app-server', () => {
        const spec = createSpec([createNode('app-1', 'app-server', 'App Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: Deployment');
        expect(result).toContain('name: app-1');
        expect(result).toContain('tier: app');
        expect(result).toContain('containerPort: 8080');
      });

      it('should generate StatefulSet for db-server', () => {
        const spec = createSpec([createNode('db-1', 'db-server', 'Database')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: StatefulSet');
        expect(result).toContain('name: db-1');
        expect(result).toContain('tier: database');
        expect(result).toContain('volumeClaimTemplates:');
        expect(result).toContain('accessModes: ["ReadWriteOnce"]');
      });

      it('should generate container resources with resource limits', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('resources:');
        expect(result).toContain('requests:');
        expect(result).toContain('limits:');
        expect(result).toContain('memory:');
        expect(result).toContain('cpu:');
      });

      it('should use custom replica count', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec, { replicaCount: 5 });

        expect(result).toContain('replicas: 5');
      });

      it('should use default replica count of 2', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('replicas: 2');
      });
    });

    describe('Network Resources', () => {
      it('should generate LoadBalancer Service for load-balancer', () => {
        const spec = createSpec([createNode('lb-1', 'load-balancer', 'Load Balancer')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: Service');
        expect(result).toContain('type: LoadBalancer');
        expect(result).toContain('port: 80');
        expect(result).toContain('port: 443');
      });

      it('should generate ClusterIP Service for DNS', () => {
        const spec = createSpec([createNode('dns-1', 'dns', 'DNS Service')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: Service');
        expect(result).toContain('type: ClusterIP');
        expect(result).toContain('port: 53');
        expect(result).toContain('protocol: UDP');
      });
    });

    describe('Security Resources', () => {
      it('should generate NetworkPolicy for firewall', () => {
        const spec = createSpec([createNode('fw-1', 'firewall', 'Firewall')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: NetworkPolicy');
        expect(result).toContain('policyTypes:');
        expect(result).toContain('- Ingress');
        expect(result).toContain('- Egress');
      });

      it('should generate ConfigMap for WAF rules', () => {
        const spec = createSpec([createNode('waf-1', 'waf', 'WAF')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: ConfigMap');
        expect(result).toContain('waf-rules');
        expect(result).toContain('modsecurity.conf');
        expect(result).toContain('SecRuleEngine On');
      });

      it('should generate DaemonSet for IDS/IPS', () => {
        const spec = createSpec([createNode('ids-1', 'ids-ips', 'IDS/IPS')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: DaemonSet');
        expect(result).toContain('falco');
        expect(result).toContain('privileged: true');
      });
    });

    describe('Storage Resources', () => {
      it('should generate PersistentVolumeClaim for san-nas', () => {
        const spec = createSpec([createNode('nas-1', 'san-nas', 'NAS Storage')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: PersistentVolumeClaim');
        expect(result).toContain('accessModes:');
        expect(result).toContain('- ReadWriteMany');
        expect(result).toContain('storageClassName: efs-sc');
        expect(result).toContain('storage: 100Gi');
      });

      it('should generate Deployment and Service for cache', () => {
        const spec = createSpec([createNode('cache-1', 'cache', 'Redis Cache')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: Deployment');
        expect(result).toContain('kind: Service');
        expect(result).toContain('redis:7-alpine');
        expect(result).toContain('containerPort: 6379');
        expect(result).toContain('tier: cache');
      });

      it('should generate PersistentVolumeClaim for storage', () => {
        const spec = createSpec([createNode('storage-1', 'storage', 'General Storage')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: PersistentVolumeClaim');
        expect(result).toContain('- ReadWriteOnce');
        expect(result).toContain('storage: 10Gi');
      });
    });

    describe('Default NetworkPolicy', () => {
      it('should include default network policies when includeNetworkPolicy is true', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, { includeNetworkPolicy: true });

        expect(result).toContain('kind: NetworkPolicy');
        expect(result).toContain('name: default-deny-ingress');
        expect(result).toContain('name: allow-internal');
      });

      it('should exclude network policies when includeNetworkPolicy is false', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec, { includeNetworkPolicy: false });

        expect(result).not.toContain('name: default-deny-ingress');
        expect(result).not.toContain('name: allow-internal');
      });
    });

    describe('Ingress', () => {
      it('should generate Ingress for web-server nodes', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec, { includeIngress: true });

        expect(result).toContain('# ============= Ingress =============');
        expect(result).toContain('kind: Ingress');
        expect(result).toContain('name: main-ingress');
        expect(result).toContain('kubernetes.io/ingress.class: nginx');
        expect(result).toContain('cert-manager.io/cluster-issuer: letsencrypt-prod');
      });

      it('should generate Ingress for load-balancer nodes', () => {
        const spec = createSpec([createNode('lb-1', 'load-balancer', 'Load Balancer')]);
        const result = exportToKubernetes(spec, { includeIngress: true });

        expect(result).toContain('kind: Ingress');
        expect(result).toContain('backend:');
        expect(result).toContain('service:');
        expect(result).toContain('name: lb-1');
      });

      it('should not generate Ingress when no web/lb nodes exist', () => {
        const spec = createSpec([createNode('db-1', 'db-server', 'Database')]);
        const result = exportToKubernetes(spec, { includeIngress: true });

        expect(result).not.toContain('kind: Ingress');
      });

      it('should not generate Ingress when includeIngress is false', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web')]);
        const result = exportToKubernetes(spec, { includeIngress: false });

        expect(result).not.toContain('kind: Ingress');
      });
    });

    describe('Name Sanitization', () => {
      it('should sanitize names for Kubernetes compatibility', () => {
        const spec = createSpec([createNode('My_Web_Server@1', 'web-server', 'My Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('name: my-web-server-1');
        expect(result).not.toContain('My_Web_Server@1');
      });

      it('should handle consecutive special characters', () => {
        const spec = createSpec([createNode('web---server', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('name: web-server');
      });

      it('should truncate long names to 63 characters', () => {
        const longId = 'this-is-a-very-long-name-that-exceeds-sixty-three-characters-limit-for-kubernetes-resources';
        const spec = createSpec([createNode(longId, 'web-server', 'Long Name')]);
        const result = exportToKubernetes(spec);

        // Check that name doesn't exceed 63 characters
        const matches = result.match(/name: ([a-z0-9-]+)/g);
        if (matches) {
          for (const match of matches) {
            const name = match.replace('name: ', '');
            expect(name.length).toBeLessThanOrEqual(63);
          }
        }
      });
    });

    describe('Comment-only Resources', () => {
      it('should generate comments for external resources', () => {
        const spec = createSpec([
          createNode('user-1', 'user', 'User'),
          createNode('internet-1', 'internet', 'Internet'),
        ]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('# User: External client');
        expect(result).toContain('# Internet: External network');
      });

      it('should generate comments for cloud resources', () => {
        const spec = createSpec([
          createNode('vpc-1', 'aws-vpc', 'AWS VPC'),
          createNode('vnet-1', 'azure-vnet', 'Azure VNet'),
        ]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('# AWS VPC: Kubernetes runs within the VPC');
        expect(result).toContain('# Azure VNet: Kubernetes runs within the VNet');
      });

      it('should generate comments for network infrastructure', () => {
        const spec = createSpec([
          createNode('router-1', 'router', 'Router'),
          createNode('switch-1', 'switch-l2', 'L2 Switch'),
        ]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('# Router: Kubernetes networking handled by CNI plugin');
        expect(result).toContain('# L2 Switch: Kubernetes networking handled by CNI plugin');
      });
    });

    describe('Service Generation', () => {
      it('should generate ClusterIP Service along with Deployment', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web Server')]);
        const result = exportToKubernetes(spec);

        // Should have both Deployment and Service
        const deploymentCount = (result.match(/kind: Deployment/g) || []).length;
        const serviceCount = (result.match(/kind: Service/g) || []).length;

        expect(deploymentCount).toBeGreaterThan(0);
        expect(serviceCount).toBeGreaterThan(0);
      });

      it('should generate headless Service for StatefulSet', () => {
        const spec = createSpec([createNode('db-1', 'db-server', 'Database')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('kind: StatefulSet');
        expect(result).toContain('kind: Service');
        expect(result).toContain('serviceName: db-1');
      });
    });

    describe('Options Configuration', () => {
      it('should apply default options correctly', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web')]);
        const result = exportToKubernetes(spec);

        // Default namespace is 'default'
        expect(result).toContain('namespace: default');
        // Default includeIngress is true
        expect(result).toContain('kind: Ingress');
        // Default includeNetworkPolicy is true
        expect(result).toContain('name: default-deny-ingress');
      });

      it('should apply custom options correctly', () => {
        const spec = createSpec([createNode('web-1', 'web-server', 'Web')]);
        const options: KubernetesExportOptions = {
          namespace: 'my-app',
          includeNamespace: true,
          includeIngress: false,
          includeNetworkPolicy: false,
          replicaCount: 3,
        };
        const result = exportToKubernetes(spec, options);

        expect(result).toContain('namespace: my-app');
        expect(result).toContain('kind: Namespace');
        expect(result).not.toContain('name: default-deny-ingress');
        expect(result).toContain('replicas: 3');
      });
    });

    describe('Secret References', () => {
      it('should reference secrets for database password', () => {
        const spec = createSpec([createNode('db-1', 'db-server', 'Database')]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('secretKeyRef:');
        expect(result).toContain('name: db-1-secret');
        expect(result).toContain('key: root-password');
      });
    });

    describe('Empty Spec Handling', () => {
      it('should handle empty spec without errors', () => {
        const spec = createSpec([]);
        const result = exportToKubernetes(spec);

        expect(result).toContain('# Kubernetes manifests generated by InfraFlow');
        expect(result).toContain('# ============= Application Resources =============');
      });
    });
  });
});
